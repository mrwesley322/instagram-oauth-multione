// oauth-server.js - Sistema Completo OAuth + Webhook + Polling
const express = require('express');
const axios = require('axios');
const crypto = require('crypto');
const path = require('path');

const app = express();
app.use(express.json());
app.use(express.static('public'));

// Configura√ß√µes
const CONFIG = {
    facebookAppId: process.env.FACEBOOK_APP_ID || '1064079752566164',
    facebookAppSecret: process.env.FACEBOOK_APP_SECRET || 'fefb66f99adad1d1c98af7',
    webhookSecret: process.env.WEBHOOK_SECRET || 'webhook_secret_123',
    multioneToken: process.env.MULTIONE_TOKEN || '68eff5505a3989e99dadbc7243c9411efba9a80ef1f59e4680c89678bf63f515',
    multioneApiUrl: process.env.MULTIONE_API_URL || 'https://sock.multi360.digital/api/messages/send',
    baseUrl: process.env.BASE_URL || 'https://instagram-oauth-multione-production.up.railway.app',
    // Token da p√°gina espec√≠fica "Teste instagram" - ATUALIZADO
    instagramPageToken: process.env.FACEBOOK_PAGE_ACCESS_TOKEN || 'EAAPHxlZBqFZAQBPImNtaCXLpMhd7GSO6v6qZCpJfj0ZBeZAFSdyLIplxRk48knmjYiZB0AuLe7CFWmvu8NefICPZB3TZCxuizQZCqZAIjI9Xaiv5bltDGFkexVSEZBBw49cXA3cTsfCywiHoq9fAXvHzzYe2hdJLeljCXLfkk4MZArpJ0RZBTUyFT4Kxs9Gofpd0855jXiCSf66FyOxilNNTHdWxEs0hGmM4ZCKUvNZCCrFfcfAGzZA2vodq4knWkgZDZD',
    // Configura√ß√µes do Polling
    pollingEnabled: process.env.POLLING_ENABLED !== 'false', // true por padr√£o
    pollingInterval: parseInt(process.env.POLLING_INTERVAL) || 120000, // 2 minutos
    instagramBusinessAccountId: process.env.INSTAGRAM_BUSINESS_ACCOUNT_ID || '17841464566186399' // ID correto da conta business
};

// Base de dados em mem√≥ria
const connectedAccounts = new Map();
const webhookSubscriptions = new Map();

// ==========================================
// SISTEMA DE POLLING INSTAGRAM
// ==========================================

// Controle do polling
let pollingInterval = null;
let lastPollingCheck = new Date(Date.now() - 24 * 60 * 60 * 1000); // 24h atr√°s inicialmente
const processedMessages = new Set(); // Cache de mensagens j√° processadas

// Iniciar sistema de polling
function startPolling() {
    if (!CONFIG.pollingEnabled) {
        console.log('‚ö†Ô∏è Polling desabilitado via configura√ß√£o');
        return;
    }

    if (!CONFIG.instagramPageToken) {
        console.log('‚ö†Ô∏è Token Instagram n√£o configurado - polling n√£o iniciado');
        return;
    }

    console.log('üîÑ Iniciando sistema de polling Instagram...');
    console.log(`‚è∞ Intervalo: ${CONFIG.pollingInterval / 1000}s`);
    console.log(`üìä Instagram Account ID: ${CONFIG.instagramBusinessAccountId}`);

    // Parar polling anterior se existir
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
    }

    // Reset do √∫ltimo check para agora
    lastPollingCheck = new Date();
    console.log(`üïê √öltimo check resetado para: ${lastPollingCheck.toISOString()}`);

    // Polling inicial ap√≥s 10 segundos
    setTimeout(() => {
        console.log('üöÄ Executando primeiro polling...');
        pollInstagramMessages();
    }, 10000);

    // Configurar intervalo
    pollingInterval = setInterval(() => {
        console.log('‚è∞ Executando polling peri√≥dico...');
        pollInstagramMessages();
    }, CONFIG.pollingInterval);

    console.log('‚úÖ Sistema de polling ativo!');
}

// Parar sistema de polling
function stopPolling() {
    if (pollingInterval) {
        clearInterval(pollingInterval);
        pollingInterval = null;
        console.log('üõë Sistema de polling parado');
    }
}

// Fun√ß√£o principal de polling
async function pollInstagramMessages() {
    try {
        const now = new Date();
        console.log(`üîç [POLLING] Verificando novas mensagens Instagram... ${now.toISOString()}`);
        console.log(`üìä [POLLING] Token: ${CONFIG.instagramPageToken ? 'Configurado' : 'Faltando'}`);
        console.log(`üÜî [POLLING] Account ID: ${CONFIG.instagramBusinessAccountId}`);
        
        // 1. Buscar conversas da conta business
        const conversations = await getInstagramConversations();
        
        if (!conversations || conversations.length === 0) {
            console.log('üì≠ [POLLING] Nenhuma conversa encontrada');
            console.log('üí° [POLLING] Poss√≠veis causas: ID incorreto, token sem permiss√µes, ou sem mensagens');
            // Atualizar timestamp mesmo sem conversas
            lastPollingCheck = now;
            return;
        }

        console.log(`üí¨ [POLLING] ${conversations.length} conversas encontradas`);

        let newMessagesCount = 0;

        // 2. Para cada conversa, buscar mensagens novas
        for (const conversation of conversations) {
            try {
                const newMessages = await getNewMessagesFromConversation(conversation.id);
                
                if (newMessages && newMessages.length > 0) {
                    console.log(`üì® [POLLING] ${newMessages.length} mensagens novas na conversa ${conversation.id}`);
                    
                    // 3. Processar cada mensagem nova
                    for (const message of newMessages) {
                        await processPolledMessage(message, conversation);
                        newMessagesCount++;
                    }
                }
            } catch (error) {
                console.error(`‚ùå [POLLING] Erro ao processar conversa ${conversation.id}:`, error.message);
            }
        }

        // 4. Atualizar timestamp da √∫ltima verifica√ß√£o
        lastPollingCheck = now;
        console.log(`üïê [POLLING] √öltimo check atualizado para: ${lastPollingCheck.toISOString()}`);

        if (newMessagesCount > 0) {
            console.log(`‚úÖ [POLLING] ${newMessagesCount} mensagens processadas e enviadas para MultiOne`);
        } else {
            console.log('üì≠ [POLLING] Nenhuma mensagem nova encontrada');
        }

    } catch (error) {
        console.error('‚ùå [POLLING] Erro no sistema de polling:', error.message);
        console.error('üìã [POLLING] Detalhes do erro:', error);
        // Atualizar timestamp mesmo com erro
        lastPollingCheck = new Date();
    }
}

// Buscar conversas do Instagram
async function getInstagramConversations() {
    try {
        console.log(`üîç [POLLING] Tentando buscar conversas...`);
        console.log(`üìä [POLLING] Instagram Business ID: ${CONFIG.instagramBusinessAccountId}`);
        console.log(`üìÑ [POLLING] P√°gina ID: 752860274568592`);
        
        // Tentar diferentes m√©todos
        let response;
        
        // M√©todo 1: Conversas da p√°gina (Facebook Messenger/Instagram unificado)
        try {
            console.log(`üîÑ [POLLING] Tentando API de conversas da p√°gina...`);
            response = await axios.get(
                `https://graph.facebook.com/v18.0/752860274568592/conversations`,
                {
                    params: {
                        access_token: CONFIG.instagramPageToken,
                        fields: 'id,updated_time,participants,message_count',
                        platform: 'instagram', // Filtrar apenas Instagram
                        limit: 25
                    }
                }
            );
            console.log(`‚úÖ [POLLING] Sucesso com conversas da p√°gina`);
        } catch (error) {
            console.log(`‚ùå [POLLING] Erro conversas da p√°gina: ${error.response?.data?.error?.message || error.message}`);
            
            // M√©todo 2: Tentar sem filtro de plataforma
            try {
                console.log(`üîÑ [POLLING] Tentando sem filtro de plataforma...`);
                response = await axios.get(
                    `https://graph.facebook.com/v18.0/752860274568592/conversations`,
                    {
                        params: {
                            access_token: CONFIG.instagramPageToken,
                            fields: 'id,updated_time,participants',
                            limit: 25
                        }
                    }
                );
                console.log(`‚úÖ [POLLING] Sucesso sem filtro de plataforma`);
            } catch (error2) {
                console.log(`‚ùå [POLLING] Erro sem filtro: ${error2.response?.data?.error?.message || error2.message}`);
                
                // M√©todo 3: Usar endpoint diferente
                try {
                    console.log(`üîÑ [POLLING] Tentando endpoint de mensagens da p√°gina...`);
                    response = await axios.get(
                        `https://graph.facebook.com/v18.0/752860274568592/messages`,
                        {
                            params: {
                                access_token: CONFIG.instagramPageToken,
                                fields: 'id,created_time,from,to,message',
                                limit: 25
                            }
                        }
                    );
                    console.log(`‚úÖ [POLLING] Sucesso com mensagens da p√°gina`);
                    
                    // Converter mensagens em formato de conversas
                    const messages = response.data.data || [];
                    const conversations = new Map();
                    
                    messages.forEach(msg => {
                        const conversationId = `conversation_${msg.from?.id || 'unknown'}`;
                        if (!conversations.has(conversationId)) {
                            conversations.set(conversationId, {
                                id: conversationId,
                                updated_time: msg.created_time,
                                participants: { data: [{ id: msg.from?.id }] }
                            });
                        }
                    });
                    
                    return Array.from(conversations.values());
                } catch (error3) {
                    console.log(`‚ùå [POLLING] Erro mensagens da p√°gina: ${error3.response?.data?.error?.message || error3.message}`);
                    throw error3;
                }
            }
        }

        return response.data.data || [];
    } catch (error) {
        console.error('‚ùå [POLLING] Todos os m√©todos falharam:', error.response?.data || error.message);
        return [];
    }
}

// Buscar mensagens novas de uma conversa
async function getNewMessagesFromConversation(conversationId) {
    try {
        // Buscar mensagens desde a √∫ltima verifica√ß√£o
        const since = Math.floor(lastPollingCheck.getTime() / 1000);
        
        const response = await axios.get(
            `https://graph.facebook.com/v18.0/${conversationId}/messages`,
            {
                params: {
                    access_token: CONFIG.instagramPageToken,
                    fields: 'id,created_time,from,to,message',
                    since: since,
                    limit: 50
                }
            }
        );

        const allMessages = response.data.data || [];
        
        // Filtrar apenas mensagens que n√£o processamos ainda
        const newMessages = allMessages.filter(msg => {
            // Verificar se j√° processamos esta mensagem
            if (processedMessages.has(msg.id)) {
                return false;
            }
            
            // Verificar se a mensagem √© posterior √† √∫ltima verifica√ß√£o
            const messageTime = new Date(msg.created_time);
            return messageTime > lastPollingCheck;
        });

        // Marcar mensagens como processadas
        newMessages.forEach(msg => processedMessages.add(msg.id));

        return newMessages;
    } catch (error) {
        console.error(`‚ùå [POLLING] Erro ao buscar mensagens da conversa ${conversationId}:`, error.response?.data || error.message);
        return [];
    }
}

// Processar mensagem obtida via polling
async function processPolledMessage(message, conversation) {
    try {
        // Verificar se a mensagem tem texto
        if (!message.message || !message.message.text) {
            console.log(`‚ö†Ô∏è [POLLING] Mensagem ${message.id} sem texto - ignorando`);
            return;
        }

        console.log(`üí¨ [POLLING] Processando mensagem: "${message.message.text}"`);

        // Obter informa√ß√µes do remetente
        const senderInfo = await getUserInfo(message.from.id, CONFIG.instagramPageToken);

        // Preparar dados para MultiOne (mesmo formato do webhook)
        const messageData = {
            number: message.from.id,
            message: message.message.text,
            sender_id: message.from.id,
            sender_name: senderInfo.name || senderInfo.username || `Usuario Instagram`,
            platform: 'instagram',
            timestamp: message.created_time,
            type: 'inbound',
            external_id: message.from.id,
            external_message_id: message.id,
            metadata: {
                conversation_id: conversation.id,
                polling_method: true,
                received_at: new Date().toISOString(),
                from_polling: true,
                token_used: CONFIG.instagramPageToken.substring(0, 20) + '...'
            }
        };

        console.log('üì¶ [POLLING] Dados preparados para MultiOne:', {
            sender: messageData.sender_name,
            message: messageData.message,
            platform: messageData.platform,
            method: 'polling'
        });

        // Enviar para MultiOne
        await sendToMultiOne(messageData);
        
        console.log(`‚úÖ [POLLING] Mensagem ${message.id} enviada para MultiOne com sucesso`);

    } catch (error) {
        console.error(`‚ùå [POLLING] Erro ao processar mensagem ${message.id}:`, error.message);
    }
}

console.log('üöÄ Inicializando Sistema OAuth + Webhook + Polling...');
console.log(`üîë Token Instagram: ${CONFIG.instagramPageToken ? 'Configurado' : 'Faltando'}`);
console.log(`üîÑ Polling: ${CONFIG.pollingEnabled ? 'Habilitado' : 'Desabilitado'}`);

// ==========================================
// ENDPOINTS OAUTH E CONFIGURA√á√ÉO
// ==========================================

// P√°gina principal
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Callback OAuth do Facebook
app.get('/oauth/callback', async (req, res) => {
    const { code, state, error } = req.query;
    
    if (error) {
        console.log('‚ùå OAuth Error:', error);
        return res.redirect('/?error=' + error);
    }
    
    try {
        console.log('üîë Processando callback OAuth...');
        
        // Trocar code por access token
        const tokenResponse = await axios.get('https://graph.facebook.com/v18.0/oauth/access_token', {
            params: {
                client_id: CONFIG.facebookAppId,
                client_secret: CONFIG.facebookAppSecret,
                redirect_uri: `${CONFIG.baseUrl}/oauth/callback`,
                code: code
            }
        });
        
        const accessToken = tokenResponse.data.access_token;
        console.log('‚úÖ Access token obtido');
        
        // Obter informa√ß√µes do usu√°rio
        const userResponse = await axios.get('https://graph.facebook.com/v18.0/me', {
            params: {
                access_token: accessToken,
                fields: 'id,name,email'
            }
        });
        
        const userId = userResponse.data.id;
        
        // Salvar token do usu√°rio
        connectedAccounts.set(userId, {
            userId,
            name: userResponse.data.name,
            email: userResponse.data.email,
            accessToken,
            connectedAt: new Date().toISOString()
        });
        
        console.log(`‚úÖ Usu√°rio ${userResponse.data.name} conectado`);
        
        res.redirect('/?success=true&user=' + encodeURIComponent(userResponse.data.name));
        
    } catch (error) {
        console.error('‚ùå Erro OAuth:', error.message);
        res.redirect('/?error=oauth_failed');
    }
});

// Listar p√°ginas do usu√°rio
app.get('/api/user/pages', async (req, res) => {
    const { userId, accessToken } = req.query;
    
    if (!accessToken) {
        return res.status(401).json({ error: 'Access token required' });
    }
    
    try {
        console.log('üìÑ Carregando p√°ginas do usu√°rio...');
        
        const pagesResponse = await axios.get('https://graph.facebook.com/v18.0/me/accounts', {
            params: { access_token: accessToken }
        });
        
        const pages = pagesResponse.data.data;
        
        // Para cada p√°gina, verificar se tem Instagram conectado
        const pagesWithInstagram = await Promise.all(pages.map(async (page) => {
            try {
                const igResponse = await axios.get(`https://graph.facebook.com/v18.0/${page.id}`, {
                    params: {
                        access_token: page.access_token,
                        fields: 'instagram_business_account'
                    }
                });
                
                return {
                    ...page,
                    instagram_account: igResponse.data.instagram_business_account || null
                };
            } catch (error) {
                return { ...page, instagram_account: null };
            }
        }));
        
        console.log(`‚úÖ ${pages.length} p√°ginas carregadas`);
        res.json({ pages: pagesWithInstagram });
        
    } catch (error) {
        console.error('‚ùå Erro ao carregar p√°ginas:', error.message);
        res.status(500).json({ error: error.message });
    }
});

// Configurar webhook automaticamente para uma p√°gina
app.post('/api/setup-webhook', async (req, res) => {
    const { pageId, pageAccessToken, userId } = req.body;
    
    try {
        console.log(`üîó Configurando webhook para p√°gina ${pageId}...`);
        
        // 1. Subscrever webhook na p√°gina
        const subscribeResponse = await axios.post(
            `https://graph.facebook.com/v18.0/${pageId}/subscribed_apps`,
            {
                subscribed_fields: 'messages,messaging_postbacks,messaging_optins,message_deliveries,messaging_referrals'
            },
            {
                params: { access_token: pageAccessToken }
            }
        );
        
        if (subscribeResponse.data.success) {
            // Salvar configura√ß√£o
            webhookSubscriptions.set(pageId, {
                pageId,
                userId,
                accessToken: pageAccessToken,
                subscribedAt: new Date().toISOString(),
                active: true
            });
            
            console.log(`‚úÖ Webhook configurado para p√°gina ${pageId}`);
            
            res.json({
                success: true,
                message: 'Webhook configurado com sucesso',
                pageId,
                webhookUrl: `${CONFIG.baseUrl}/webhook/instagram`,
                pollingActive: CONFIG.pollingEnabled
            });
        } else {
            throw new Error('Falha ao configurar webhook');
        }
        
    } catch (error) {
        console.error('‚ùå Erro ao configurar webhook:', error.message);
        res.status(500).json({ 
            success: false, 
            error: error.message 
        });
    }
});

// ==========================================
// ENDPOINTS DE CONTROLE DO POLLING
// ==========================================

// Status do polling
app.get('/api/polling/status', (req, res) => {
    res.json({
        enabled: CONFIG.pollingEnabled,
        active: pollingInterval !== null,
        interval: CONFIG.pollingInterval,
        lastCheck: lastPollingCheck.toISOString(),
        processedMessages: processedMessages.size,
        instagramAccountId: CONFIG.instagramBusinessAccountId,
        tokenConfigured: CONFIG.instagramPageToken ? true : false
    });
});

// Controlar polling manualmente
app.post('/api/polling/control', (req, res) => {
    const { action } = req.body;
    
    try {
        switch (action) {
            case 'start':
                startPolling();
                res.json({ success: true, message: 'Polling iniciado', active: true });
                break;
                
            case 'stop':
                stopPolling();
                res.json({ success: true, message: 'Polling parado', active: false });
                break;
                
            case 'restart':
                stopPolling();
                setTimeout(() => startPolling(), 1000);
                res.json({ success: true, message: 'Polling reiniciado', active: true });
                break;
                
            case 'poll_now':
                pollInstagramMessages();
                res.json({ success: true, message: 'Polling manual executado' });
                break;
                
            default:
                res.status(400).json({ error: 'A√ß√£o inv√°lida. Use: start, stop, restart, poll_now' });
        }
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
});

// ==========================================
// WEBHOOK INSTAGRAM (MANTIDO PARA COMPATIBILIDADE)
// ==========================================

// Verifica√ß√£o do webhook (GET)
app.get('/webhook/instagram', (req, res) => {
    const mode = req.query['hub.mode'];
    const token = req.query['hub.verify_token'];
    const challenge = req.query['hub.challenge'];
    
    console.log('üîç Verifica√ß√£o webhook:', { mode, token, challenge });
    
    if (mode === 'subscribe' && token === CONFIG.webhookSecret) {
        console.log('‚úÖ Webhook Instagram verificado');
        res.status(200).send(challenge);
    } else {
        console.log('‚ùå Verifica√ß√£o falhou');
        res.sendStatus(403);
    }
});

// Receber mensagens do webhook (POST)
app.post('/webhook/instagram', express.raw({type: 'application/json'}), async (req, res) => {
    try {
        // Verificar se h√° body
        if (!req.body || req.body.length === 0) {
            console.log('‚ö†Ô∏è [WEBHOOK] Body vazio recebido');
            return res.status(200).send('OK');
        }

        // Tentar fazer parse do JSON
        let body;
        try {
            const bodyString = req.body.toString();
            if (!bodyString || bodyString.trim() === '') {
                console.log('‚ö†Ô∏è [WEBHOOK] Body string vazio');
                return res.status(200).send('OK');
            }
            body = JSON.parse(bodyString);
        } catch (parseError) {
            console.error('‚ùå [WEBHOOK] Erro ao fazer parse do JSON:', parseError.message);
            console.error('üìã [WEBHOOK] Body recebido:', req.body.toString());
            return res.status(400).send('INVALID_JSON');
        }

        console.log('üì∏ [WEBHOOK] Instagram webhook recebido:', JSON.stringify(body, null, 2));
        
        // Processar cada entrada
        if (body.entry && Array.isArray(body.entry)) {
            for (const entry of body.entry) {
                await processWebhookEntry(entry);
            }
        } else {
            console.log('‚ö†Ô∏è [WEBHOOK] Nenhuma entrada encontrada no webhook');
        }
        
        res.status(200).send('EVENT_RECEIVED');
    } catch (error) {
        console.error('‚ùå [WEBHOOK] Erro processando webhook:', error);
        res.status(500).send('ERROR');
    }
});

// Processar entrada do webhook
async function processWebhookEntry(entry) {
    const pageId = entry.id;
    
    console.log(`üîç [WEBHOOK] Processando entrada para p√°gina ${pageId}...`);
    
    // Usar token fixo para testers
    const subscription = {
        pageId: pageId,
        userId: 'tester_user',
        accessToken: CONFIG.instagramPageToken,
        subscribedAt: new Date().toISOString(),
        active: true
    };
    
    console.log(`‚úÖ [WEBHOOK] Subscription ativa para p√°gina ${pageId}`);
    
    // Processar mensagens
    if (entry.messaging) {
        console.log(`üí¨ [WEBHOOK] Processando ${entry.messaging.length} mensagens...`);
        for (const messaging of entry.messaging) {
            await processInstagramMessage(messaging, subscription);
        }
    }
}

// Processar mensagem do Instagram (Webhook)
async function processInstagramMessage(messaging, subscription) {
    try {
        if (messaging.message && messaging.message.text) {
            console.log(`üí¨ [WEBHOOK] Mensagem Instagram recebida: "${messaging.message.text}"`);
            
            // Marcar como processada para evitar duplicatas com polling
            if (messaging.message.mid) {
                processedMessages.add(messaging.message.mid);
            }
            
            // Obter informa√ß√µes do remetente
            const senderInfo = await getUserInfo(messaging.sender.id, subscription.accessToken);
            
            const messageData = {
                number: messaging.sender.id,
                message: messaging.message.text,
                sender_id: messaging.sender.id,
                sender_name: senderInfo.name || `Usuario Instagram`,
                platform: 'instagram',
                timestamp: new Date().toISOString(),
                type: 'inbound',
                external_id: messaging.sender.id,
                external_message_id: messaging.message.mid,
                metadata: {
                    page_id: subscription.pageId,
                    received_at: new Date().toISOString(),
                    from_webhook: true,
                    token_used: subscription.accessToken.substring(0, 20) + '...'
                }
            };
            
            console.log('üì¶ [WEBHOOK] Dados preparados para MultiOne:', {
                sender: messageData.sender_name,
                message: messageData.message,
                platform: messageData.platform,
                method: 'webhook'
            });
            
            // Enviar para MultiOne
            await sendToMultiOne(messageData);
        }
    } catch (error) {
        console.error('‚ùå [WEBHOOK] Erro processando mensagem Instagram:', error.message);
    }
}

// Obter informa√ß√µes do usu√°rio
async function getUserInfo(userId, accessToken) {
    try {
        console.log(`üë§ Buscando informa√ß√µes do usu√°rio ${userId}...`);
        
        const response = await axios.get(`https://graph.facebook.com/v18.0/${userId}`, {
            params: {
                access_token: accessToken,
                fields: 'name,first_name,profile_pic,username'
            }
        });
        
        console.log(`‚úÖ Info do usu√°rio obtida: ${response.data.name || response.data.username || 'Nome n√£o dispon√≠vel'}`);
        return response.data;
    } catch (error) {
        console.log(`‚ö†Ô∏è N√£o foi poss√≠vel obter info do usu√°rio ${userId}:`, error.message);
        return { name: 'Usuario Instagram' };
    }
}

// Enviar para MultiOne
async function sendToMultiOne(messageData) {
    try {
        console.log('üöÄ Enviando para MultiOne:', {
            sender: messageData.sender_name,
            message: messageData.message,
            platform: messageData.platform,
            method: messageData.metadata?.from_webhook ? 'webhook' : 'polling',
            timestamp: messageData.timestamp
        });
        
        const response = await axios.post(CONFIG.multioneApiUrl, messageData, {
            headers: {
                'Authorization': `Bearer ${CONFIG.multioneToken}`,
                'Content-Type': 'application/json'
            },
            timeout: 15000
        });
        
        console.log('‚úÖ Mensagem enviada para MultiOne com sucesso!');
        console.log('üìä Resposta MultiOne status:', response.status);
        
        return response.data;
        
    } catch (error) {
        console.error('‚ùå ERRO ao enviar para MultiOne:');
        console.error('üìç URL:', CONFIG.multioneApiUrl);
        console.error('üìä Status:', error.response?.status);
        console.error('üìã Dados:', error.response?.data);
        console.error('‚ö†Ô∏è Message:', error.message);
        throw error;
    }
}

// ==========================================
// ENDPOINTS DE MONITORAMENTO
// ==========================================

// Health check
app.get('/health', (req, res) => {
    res.json({
        status: 'OK',
        service: 'Instagram OAuth + Webhook + Polling System',
        timestamp: new Date().toISOString(),
        connections: {
            connectedAccounts: connectedAccounts.size,
            activeWebhooks: webhookSubscriptions.size,
            multioneConnection: CONFIG.multioneToken ? 'configured' : 'missing',
            instagramToken: CONFIG.instagramPageToken ? 'configured' : 'missing'
        },
        polling: {
            enabled: CONFIG.pollingEnabled,
            active: pollingInterval !== null,
            interval: CONFIG.pollingInterval,
            lastCheck: lastPollingCheck.toISOString(),
            processedMessages: processedMessages.size
        },
        config: {
            baseUrl: CONFIG.baseUrl,
            facebookAppId: CONFIG.facebookAppId,
            multioneApiUrl: CONFIG.multioneApiUrl,
            instagramBusinessAccountId: CONFIG.instagramBusinessAccountId
        }
    });
});

// Logs recentes
const recentLogs = [];
const originalConsoleLog = console.log;
console.log = (...args) => {
    const logEntry = {
        timestamp: new Date().toISOString(),
        message: args.join(' '),
        level: 'info'
    };
    recentLogs.unshift(logEntry);
    if (recentLogs.length > 100) recentLogs.pop();
    originalConsoleLog(...args);
};

app.get('/api/logs', (req, res) => {
    res.json({ logs: recentLogs.slice(0, 50) });
});

// ==========================================
// UTILIT√ÅRIOS E TESTES
// ==========================================

// Testar conex√£o MultiOne
app.post('/api/test/multione', async (req, res) => {
    try {
        const testMessage = {
            number: 'test_user_polling_system',
            message: 'TESTE FINAL - OAuth + Polling System ‚Üí MultiOne - Funcionando!',
            sender_id: 'polling_test_final',
            sender_name: 'Polling Test System',
            platform: 'instagram',
            timestamp: new Date().toISOString(),
            type: 'inbound',
            test: true
        };
        
        const result = await sendToMultiOne(testMessage);
        
        res.json({ 
            success: true, 
            result,
            message: 'Teste manual enviado para MultiOne com sucesso!'
        });
        
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: error.message
        });
    }
});

// Testar polling manualmente
app.post('/api/test/polling', async (req, res) => {
    try {
        if (!CONFIG.instagramPageToken) {
            return res.status(400).json({ 
                success: false, 
                error: 'Token Instagram n√£o configurado' 
            });
        }
        
        // Executar polling manual
        await pollInstagramMessages();
        
        res.json({ 
            success: true, 
            message: 'Polling manual executado com sucesso!',
            status: {
                lastCheck: lastPollingCheck.toISOString(),
                processedMessages: processedMessages.size
            }
        });
        
    } catch (error) {
        res.status(500).json({ 
            success: false, 
            error: error.message 
        });
    }
});

// ==========================================
// INICIALIZA√á√ÉO DO SERVIDOR
// ==========================================

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
    console.log('üéâ =======================================');
    console.log('üöÄ INSTAGRAM OAUTH + POLLING SYSTEM ATIVO!');
    console.log('üéâ =======================================');
    console.log(`üåê Servidor: ${CONFIG.baseUrl}`);
    console.log(`üì± Interface: ${CONFIG.baseUrl}`);
    console.log(`üîó OAuth Callback: ${CONFIG.baseUrl}/oauth/callback`);
    console.log(`üì∏ Webhook: ${CONFIG.baseUrl}/webhook/instagram`);
    console.log(`üíö Health: ${CONFIG.baseUrl}/health`);
    console.log('üéâ =======================================');
    console.log(`üìã Config: App ID ${CONFIG.facebookAppId}`);
    console.log(`üîë MultiOne: ${CONFIG.multioneToken ? 'Configurado' : 'Faltando'}`);
    console.log(`üì∏ Instagram Token: ${CONFIG.instagramPageToken ? 'Configurado' : 'Faltando'}`);
    console.log(`üîÑ Polling: ${CONFIG.pollingEnabled ? 'Habilitado' : 'Desabilitado'} (${CONFIG.pollingInterval/1000}s)`);
    console.log('üéâ =======================================');
    
    // Inicializar sistema de polling ap√≥s 3 segundos
    if (CONFIG.pollingEnabled && CONFIG.instagramPageToken) {
        console.log('üîÑ Iniciando sistema de polling em 3 segundos...');
        setTimeout(() => {
            startPolling();
        }, 3000);
    } else {
        console.log('‚ö†Ô∏è Polling n√£o iniciado:');
        if (!CONFIG.pollingEnabled) console.log('   - Polling desabilitado');
        if (!CONFIG.instagramPageToken) console.log('   - Token Instagram n√£o configurado');
    }
});

// Cleanup ao encerrar aplica√ß√£o
process.on('SIGTERM', () => {
    console.log('üõë Encerrando aplica√ß√£o...');
    stopPolling();
    process.exit(0);
});

process.on('SIGINT', () => {
    console.log('üõë Encerrando aplica√ß√£o...');
    stopPolling();
    process.exit(0);
});

module.exports = app;
